function y=upfirdn(x,h,p,q)
%Upsample, apply an FIR filter and downsample
%
%I am creating this function because I do not have
%The MATLAB Signal Processing Toolbox.
%
% Based on:
% [1] "Programs for Digital Signal Processing" Edited by IEEE
%   Digital Signal Processing Committee; IEEE Acoustics, Speech,
%   and Signal Processing Society. Chapter 8, Section 8.2
%
% y=upfirdn(x,h,p,q)
%
% Similarly to MATLAB upfirdn function it introduces a group delay!.
%
% The algorithm is very simple:
%
%A) Increase sampling rate by a factor p: Insert p-1 zero valued
%samples between each pair of input samples.
%B) Apply the compensation filter h.
%C) Downsample the filtered data by selecting every q-th point
%
%
%
%
%% Remarks
%
%The FORTRAN algorithm in Ref [1] has been implemented here. However
%MATLAB's original upfirdn function behaves differently from this
%one, despite being cited in MATLAB's help as the core of its
%algorithm. Therefore, although the code is there ready to use,
%I have implemented an alternative behaviour to match that of MATLAB.
%But it is no longer a polyphase filter.
%
%
%It does not accept a set of signals (matrix).
%
%% Parameters
%
% x - The discrete digital signal signal to be resampled
% h - Filter coefficients
% p - Interpolation coefficient. Must be a positive integer
% q - Decimation coefficient. Must be a positive integer
%
%
%
% @Copyright 2008-9
% Author: Felipe Orihuela-Espina
% Date: 9-Jun-2008
%
% See also resample
%

if (abs(round(p))~=p || p==0)
    error('P must be a positive integer.');
end
if (abs(round(q))~=q || q==0)
    error('Q must be a positive integer.');
end



%% To have the same behaviour as MATLAB's upfirdn 
%A) Increase sampling rate by a factor p: Insert p-1 zero valued
%samples between each pair of input samples.
%%This works (the following 5 lines) but it is EXTREMELY slow
%pad=zeros(1,p-1);
%tmp=length(x);
% for ii=tmp:-1:2
%    x=[x(1:ii-1) pad x(ii:end)];
% end
B=zeros(1,p*length(x));
B(1:p:end)=x;
x=B;
clear B

%B) Apply compensation filter
tempX=conv(x,h);

%C) Downsample the filtered data by selecting every q-th point
y=tempX(1:q:end);



%% To have the same behaviour as in Ref [1]
% %In MATLAB upfirdn takes the whole filter, whereas in my case
% %srinit just take half (because of symmetry)!!
% temp=floor(length(h)/2);
% h(1:temp)=[];
% h=h*2;
% 
% %This program converts the sampling rate of a signal by a ratio
% %of P/Q. The program calls srinit to initialize and then
% %calls srconv suppliying input data through bufm and taking
% %output data from bufl.
% 
% %Initialize conversion routine
% [qbuf,coefs,ictr,ierr,iq,jq,il]=srinit(p,q,h);
% %disp(['Initialization Error Code: ' num2str(ierr)]);
% %Process data
% y=srconv(x,p,q,qbuf,coefs,ictr,iq,jq,il);
% y=y; %Added by FOE

%%=============================
%% Auxiliary functions
%%=============================
function bufl=srconv(bufm,L,M,qbuf,coefs,ictr,iq,jq,il)
%Sampling rate conversion
%Converts the sampling rate of a signal by the ratio L/M
%SRINIT must be called prioir to calling this routine.
%
% L - interpolation ratio
% M - decimation ratio
% bufm -  input data buffer of size ND*M
% bufl -  output data buffer of size ND*L
% nd - Any positive integer.
% qbuf - State variable buffer
% coefs - scrambled coefficient vector generated by srinit
% ictr - control array generated by srinit and used by srconv
%

ND=floor(length(bufm)/M);

mb=1; %index of bufm
lb=1;
L=il;
for ii=1:ND
    %Compute L output samples
    k=1;
    for jj=1:L
        jd = ictr(k);
        ic = ictr(k+1);
        k=k+2;
        %update qbuf
        while (jd~=0)
            qbuf(jq)=bufm(mb);
            jq1=jq+iq;
            qbuf(jq1)=bufm(mb);
            mb=mb+1;
            jq=jq-1;
            if (jq==0)
                jq=iq;
            end
            jd=jd-1;
        end
        %compute 1 sample of output data and store in bufl
        sum=0;
        for kq=1:iq
            icof=kq+ic;
            iqb=kq+jq;
            sum=sum+qbuf(iqb)*coefs(icof);
        end
        bufl(lb)=sum;
        lb=lb+1;
    end
end

function [qbuf,coefs,ictr,ierr,iq,jq,il]=srinit(L,M,coef)
% Initialization for srconv which converts the sampling rate
%of a signal by the ratio of L/M
%
% L - interpolation ratio
% M - decimation ratio
% qbuf - state variable buffer, intermediate internal buffer
% nq - size of qbuf, greater or equal to
%       2*(the next greatest integer of N/L)
% coef - array of coefficients for FIR interpolating filter
% n - number of taps in the FIR interpolation filter
% coefs - scrambled coefficient vector generated by srinit
%nc - size of coefs, equal to or greater than
%       L*(the next greatest integer of N/L)
% ictr - control array generated by srinit and used by srconv
% ni - size of ictr vector equal or greater than 2*L
% ierr - Error code for debugging
%           0 - No errors found in initialization
%           1 - qbuf (nq) too small
%           2 - coefs (nc) too small
%           3 - ictr (ni) too small
%

%%%%%%%
%These were originaly in the main body of the function
%iq=0; %these first three were declared as common (global??) 
%jq=0;
%il=0;

n=2*length(coef)-1;%119; %Number of taps in the filter (Length of the filter????)
nc=L*ceil(n/L);%120; %size of coefs, equal to or greater than
        %L*(the next greatest integer of N/L)
nq=2*ceil(n/L);%30; %Size of qbuf. Equal or greater than 2*Q, where Q
    %is the next greatest integer of N/L.
ni=2*L; %size of ictr
%%%%%%%
ictr=zeros(1,ni);



ierr=0;
il=L;
%compute iq
iq=floor(n/L);
if (n~=iq*L), iq=iq+1; end
np=iq*L;
if (nq<2*iq), ierr=1; end
if (nc<np), ierr=2; end
%In FORTRAN, if an expression specifies the division of
%an integer by an integer, the result is rounded to an
%integer closer to zero. For example, (-7)/3 has the value -2.
%http://publib.boulder.ibm.com/infocenter/macxhelp/v6v81/index.jsp?topic=/com.ibm.xlf81m.doc/pgs/lr41.htm
ncf=floor((n+1)/2);
fl=L;

%zero out qbuf
qbuf=zeros(1,nq);

%scramble coefficients
i=1;
for ml=1:L
    for mq=1:iq
        mx=(ml-1)+(mq-1)*L;
        if (mx<ncf), mm=ncf-mx; end;
        if (mx>=ncf), mm=mx-(n-ncf-1); end;
        if (mm<=ncf), coefs(i)=coef(mm)*fl; end;
        if (mm>ncf), coefs(i)=0; end;
        i=i+1;
    end
end
%setup of moving address pointer
jq=iq;

%generate control array ictr
lm=L*M;
if (ni<2*L), ierr=3; end;
lc=0;
mc=0;
incr=0;
k=1;
for ii=1:lm
    if (lc==0), incr=incr+1; end;
    if (~(mc<(M-1)))
        %number of samples to update qbuf
        ictr(k)=incr;
        incr=0;
        k=k+1;
        %starting location in coefs vector
        ictr(k)=lc*iq;
        incr=0;
        mc=-1;
        k=k+1;
    end
    lc=lc+1;
    if (lc>=L), lc=0; end;
    mc=mc+1;
end
